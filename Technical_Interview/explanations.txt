Question 1:
Q1 uses a partial nested loop, with a efficiency of O((n + 1)(n/2)). Since the words are alphabatized and the letters' ORD are compared to discard uneeded letters for subsequent loops, this reduces the amount of looping. Worst case scenario would be if the t string was 'aaa', where a loops through the entirety of string s,  while the best case scenario would be if the string was 'zzz', as the former would be a full nested loop whereas the latter would be simplified as O(n + 1). In terms of space effiency, depending how many letters there are shared between the strings, it would increase or decrease the amount of work. So for the innermost loop the average would be O(3). 

Question 2:
Q2 similarly uses a nested loop, but conditions must be met in order for the loop to end. Originally, I had implemented a conventional nest loop, but came to a conclusion that finding the pattern while looping once through would increase the efficiency. The best case scenario would be if the input only has a single palindromic substring that's on the short side, worst case would be a word with several longer palindrom. The guess is that the palindroms within a string will generally loop less than half the length of the string itself. In the case of the first test string, 'racecarat', there's 2 substring that would pause the loop to go into a nested loop: 'racecar' and 'ara'. The first one would loop three times, where the latter would loop a single time. Considering the loop starts at index 1 of the string, this string would have an efficiency of O((n-1)(n/2)). As for space effiency, 4 variables are being modified when incrementing forward, where it's 2 for when a palindrom is spotted, so the outer loop would have a space efficiency of n(4), the inner would have an effiency of n(5). 
